<code>

	<style scoped>
		/*----------  style  ----------*/
		
        /* edge flow Effect */
        .ai-neural-graph .flow {
		  stroke-dasharray: 8;
		  animation: dash 0.5s linear;
		  animation-iteration-count: infinite;
		}
		@keyframes dash {
		  to {
		    stroke-dashoffset: -16;
		  }
		}

	</style>

	
	/*----------  最外层element会自动增加组件同名 class="ai-neural-graph"  ----------*/
	<template>		
		<el-container style="height:100%;">
            <el-header style="height:40px;line-height: 40px;">
                <mx-entity-class-keys-cascader root="/matrix/entity" 
                    multiplenable="true" 
                    style="position: absolute;z-index: 100;"></mx-entity-class-keys-cascader>
            </el-header>
            <el-main ref="graphContainer" style="overflow:auto;width:100%;height:100%;padding:0px;">
			</el-main>
		</el-container>
	</template>

	/*----------  id是vue组件的name，内容是vue组件的option参数  ----------*/
	<script id="ai-neural-graph">
	{
        delimiters: ['#{', '}#'],
		props: {
            model: Object
		},
		data(){
			return {
                graph: {
                    inst: null,
                    hidden: 300
                },
				setup: {
                    show: false
                }
			}
		},
		created(){
			
		},
		mounted(){
            this.initGraph(this.$refs.graphContainer.$el);
		},
		methods: {
			initGraph(container){
                // Checks if the browser is supported
                if (!mxClient.isBrowserSupported())
                {
                    // Displays an error message if the browser is not supported.
                    mxUtils.error('Browser is not supported!', 200, false);
                }
                else
                {
                    mxConstants.SHADOWCOLOR = '#c0c0c0';
                    
                    // Creates the graph inside the given container
                    let graph = this.graph.inst = new mxGraph(container);

                    // No size handles, please...
                    graph.setCellsResizable(false);

                    // Makes all cells round with a white, bold label
                    var style = graph.stylesheet.getDefaultVertexStyle();
                    // style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_ELLIPSE;
                    // style[mxConstants.STYLE_PERIMETER] = mxPerimeter.EllipsePerimeter;
                    style[mxConstants.STYLE_FONTCOLOR] = 'white';
                    style[mxConstants.STYLE_GRADIENTCOLOR] = 'white';
                    style[mxConstants.STYLE_FONTSTYLE] = mxConstants.FONT_BOLD;
                    style[mxConstants.STYLE_FONTSIZE] = 12;
                    style[mxConstants.STYLE_SHADOW] = true;

                    // Makes all edge labels gray with a white background
                    style = graph.stylesheet.getDefaultEdgeStyle();
                    style[mxConstants.STYLE_FONTCOLOR] = 'gray';
                    style[mxConstants.STYLE_FONTSTYLE] = mxConstants.FONT_BOLD;
                    style[mxConstants.STYLE_FONTCOLOR] = 'black';
                    style[mxConstants.STYLE_STROKEWIDTH] = 2;
                    
                    // Enables rubberband selection
                    new mxRubberband(graph);
                    
                    // Gets the default parent for inserting new cells. This
                    // is normally the first child of the root (ie. layer 0).
                    var parent = graph.getDefaultParent();
                                    
                    // Adds cells to the target model in a single step
                    // using custom ids for the vertices and edges
                    var w = 120;
                    var h = 40;
                    
                    graph.getModel().beginUpdate();
                    try
                    {
                        var input1 = graph.insertVertex(parent, 'it_linux:192.168.190.174:disk:free', 'it_linux:192.168.190.174:disk:free', 20, 20, w, h, 'fillColor=blue');
                        var input2 = graph.insertVertex(parent, 'it_linux:192.168.190.174:disk:pfree', 'it_linux:192.168.190.174:disk:pfree', 20, 100, w, h, 'fillColor=blue');
                        var input3 = graph.insertVertex(parent, 'it_linux:192.168.190.175:disk:free', 'it_linux:192.168.190.175:disk:free', 20, 200, w, h, 'fillColor=blue');
                        var input4 = graph.insertVertex(parent, 'it_linux:192.168.190.175:disk:pfree', 'it_linux:192.168.190.175:disk:pfree', 20, 300, w, h, 'fillColor=blue');
                        
                        var hidden = graph.insertVertex(parent, 'hidden', this.model.hidden, 300, 120, 60, 60, 'fillColor=green');
                        
                        var output1 = graph.insertVertex(parent, 'it_linux:192.168.190.174:disk:free:output', 'it_linux:192.168.190.174:disk:free:output', 600, 20, w, h, 'fillColor=red');
                        var output2 = graph.insertVertex(parent, 'it_linux:192.168.190.175:disk:pfree:output', 'it_linux:192.168.190.175:disk:pfree:output', 600, 200, w, h, 'fillColor=red');
                        
                        var input1h = graph.insertEdge(parent, 'input1h', 'input1h', input1, hidden, 'strokeColor=blue;verticalAlign=bottom');
                        var input2h = graph.insertEdge(parent, 'input2h', 'input2h', input2, hidden, 'strokeColor=blue;verticalAlign=bottom');
                        var input3h = graph.insertEdge(parent, 'input3h', 'input3h', input3, hidden, 'strokeColor=blue;verticalAlign=bottom');
                        var input4h = graph.insertEdge(parent, 'input4h', 'input4h', input4, hidden, 'strokeColor=blue;verticalAlign=bottom');
                        
                        var houtput1 = graph.insertEdge(parent, 'houtput1', 'houtput1', hidden, output1, 'strokeColor=blue;align=left;verticalAlign=bottom');
                        var houtput2 = graph.insertEdge(parent, 'houtput2', 'houtput2', hidden, output2, 'strokeColor=blue;verticalAlign=bottom');

                        
                        
                    }
                    finally
                    {
                        // Updates the display
                        graph.getModel().endUpdate();
                    }

                    // Adds animation to edge shape and makes "pipe" visible
                    let edges = graph.getChildEdges(graph.getDefaultParent());
                        
                    _.forEach(edges,(v)=>{
                        let state = graph.view.getState(v);
                        state.shape.node.getElementsByTagName('path')[0].removeAttribute('visibility');
                        state.shape.node.getElementsByTagName('path')[1].setAttribute('class', 'flow');
                    })
                }
            }
		}
	
	}
	</script>

</code>
