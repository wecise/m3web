<code>

	<style scoped>
		/*----------  style  ----------*/
        .pace{
            display: none!important;
        }
        
        .topological-graph-component{
            height: 100%;
        }

        
		.topological-graph-component .el-input--small .el-input__inner {
            height: 35px;
            line-height: 35px;
        }

        .topological-graph-component .form-control-transparent{
            border-bottom: unset;
        }

        

        .topological-graph-component .tools-search .form-control,
        .topological-graph-component .tools-search .text-muted {
			color: #dddddd;
            background: unset;
            border: unset;
		}

		.topological-graph-component .node-menu{
			width:20vw;
		}

        .topological-graph-component .tools-search {
			width: 100%;
            float: right;
            height: 100%;
            line-height: 30px;
            border: unset;
            background: #ffffff;
        }
        
        .topological-graph-component .tools-search .el-input__inner {
			background: transparent;
            border: unset;
        }
        .topological-graph-component .tools-search .el-input-group__append, 
        .topological-graph-component .tools-search .el-input-group__prepend{
            border:unset;
        }

        /* ToolBar */
        .topological-graph-component .tools {
			overflow: hidden;
            width: 45%;
            height: 100%;
            display: flex;
            padding: 0px;
		}

        .topological-graph-component .tools .el-color-picker__trigger{
            width: 18px;
            height: 18px;
            padding: 0px;
            border: unset;
        }
        .topological-graph-component .tools > a + a {
            padding: 0 5px;
        }
        .topological-graph-component .tools > a{
            line-height: 24px;
            height:24px;
        }

        .topological-graph-component .controlBar{
            position:absolute;
            z-index:1000;
			top:5px;
			right:25px;
        }

        .topological-graph-component .outlineContainer {
			position:absolute;
            z-index:1000;
			overflow:hidden;
			top:35px;
			right:25px;
			width: 80px;
			height:80px;
            padding:5px;
			background: #ffffff;
			box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
			border: unset;
            border-radius: 5px;
		}

        .topological-graph-component .search-toolbar{        
            position: absolute;
            width: auto;
            max-width: 30vw;
            height: auto;
            z-index: 1000;
            top:5px;
            left:5px;
            box-shadow: 1px 2px 1px rgba(0,0,0,.15);
            border: 1px solid #ddd;
            background: #ffffff;
        }
        .topological-graph-component .search-toolbar .el-input__inner,
        .topological-graph-component .search-toolbar .el-button{
            border:unset;
        } 

        .topological-graph-component .vertical-toolbar{
            position: absolute;
            width: 29px;
            height: auto;
            background: #ffffff;
            z-index: 1000;
            right: 25px;
            bottom: 100px;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 0px 6px;
        }
        .topological-graph-component .vertical-toolbar > button{
            margin: 0 5px;
        }
        .topological-graph-component .vertical-toolbar > .el-dropdown,
        .topological-graph-component .vertical-toolbar > .el-color-picker{
            margin: 5px;
        }

        .topological-graph-component .horizontal-toolbar{
            position: absolute;
            width: auto;
            height: 30px;
            line-height: 30px;
            background: #ffffff;
            z-index: 1000;
            right: 25px;
            bottom: 60px;
            -webkit-transform: translateZ(0);
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 0px 6px;
        }

        .topological-graph-component .footerbar {
            width: 100%;
            height: 200px!important;
            line-height: 200px!important;
            padding: 0px;
            background: #f7f7f7;
        }
        .topological-graph-component .footerbar > a{
            padding: 0px 10px 0px 5px;
            background: #fff;
            height: 30px;
            line-height: 30px;
            overflow-y: auto;
            border-radius: 20px;
        }
        .topological-graph-component .footerbar > a:hover{
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
        }
        .topological-graph-component .footerbar > a > span{
            background: #ddd;
            padding: 5px 8px;
            border-radius: 15px;
        }
        .topological-graph-component .footerbar > a + a{
            margin-left: 5px;
        }

        .topological-graph-component svg foreignObject div {
            user-select: none;
        }

        .el-tooltip__popper.is-light {
            background: #FFF;
            /* border: 1px solid #303133; */
            padding: 10px;
            position: absolute;
            background: #fff;
            min-width: 150px;
            border-radius: 4px;
            border: 1px solid #ebeef5;
            padding: 12px;
            z-index: 2000;
            color: #606266;
            line-height: 1.4;
            text-align: justify;
            font-size: 14px;
            box-shadow: 0 2px 12px 0 rgba(0,0,0,.1);
            word-break: break-all;
        }

        .el-tooltip__popper is-light .popper__arrow, .el-popper .popper__arrow:after {
            position: absolute;
            display: block;
            width: 0;
            height: 0;
            border-color: transparent!important;
            border-style: solid;
        }

        .el-divider.el-divider--horizontal{
            margin: 0px;
        }

        /* 工具栏拾色器 */
        .topological-graph-component .el-color-picker{
            padding: unset!important;
        }

        .topological-graph-component .el-color-picker--small .el-color-picker__trigger {
            height: 18px;
            width: 18px;
            padding: 2px;
            margin-top: 4px;
            border:none;
        }

        .topological-graph-component .el-input-group__append, 
        .topological-graph-component .el-input-group__prepend,
        .topological-graph-component .el-input__inner{
            border-radius: 0px;
        }
        .topological-graph-component .el-input.is-disabled .el-input__inner {
            background-color: #ffffff;
        }

        .el-color-dropdown.el-color-picker-dropdown.el-color-picker__panel{
            z-index: 30000!important;
        }

        /* jsPanel graphAction */
        .graphAction .input-with-select.el-input.el-input--small{
            border-bottom: 1px solid #ddd!important;
        }
        .graphAction .topological-analysis-input .el-input-group__append, .graphAction .el-input-group__prepend, .graphAction .el-input__inner {
            background-color: transparent!important;
            border: unset!important;
        }
        .graphAction .topological-analysis-form .el-input__inner{
            background-color: #FFF!important;
            border:1px solid #DCDFE6!important;
            height: 32px!important;
            line-height: 32px!important;
        }


        /* graph */
        .topological-search-toolbar-graph .el-input-group__prepend{
            background: transparent;
            border: unset;
        }

        /* graphAdv  */
        .topological-search-toolbar-graphAdv .el-textarea__inner,
        .topological-search-toolbar-path .el-radio-button__inner{
            border:unset;
        }
        .topological-search-toolbar-path .el-radio-button__orig-radio:checked+.el-radio-button__inner {
            color: #333333;
            background-color: #ffffff;
            border-color: #ffffff;
            -webkit-box-shadow: unset;
            box-shadow: unset;
        }
        .topological-search-toolbar-path .el-radio-button__orig-radio:checked+.el-radio-button__inner:before {
            content: "";
            position: absolute;
            bottom: -2px;
            left: 29px;
            border-width: 0 6px 6px;
            border-style: solid;
            border-color: #2790e2 transparent;
            display: block;
            width: 0;
            -webkit-transition-duration: 0.3s;
            transition-duration: 0.3s;
            -webkit-transition-property: transform;
            transition-property: transform;
        }
        .topological-search-toolbar-path .el-radio-button__orig-radio:checked+.el-radio-button__inner:after {
            content: "";
            position: absolute;
            bottom: -2px;
            left: 30px;
            border-width: 0 5px 5px;
            border-style: solid;
            border-color: #ffffff transparent;
            display: block;
            width: 0;
            /* -webkit-transition-duration: 0.3s;
            transition-duration: 0.3s;
            -webkit-transition-property: transform;
            transition-property: transform; */
        }

        .topological-graph-component .div-hover-effect:hover{
            background: #f7f7f7;
        }
        .topological-graph-component .div-hover-effect:visited,
        .topological-graph-component .div-hover-effect:focus{
            background: #f7f7f7;
        }

        .info-popper{
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            background: #fff;
            padding: 10px;
            outline: unset;
        }

        .info-popper .el-divider__text, 
        .info-popper .el-link {
            font-weight: unset;
            font-size: 12px;
        }

        .el-textarea__inner{
            border: unset; 
            transition: 0.4s;
        }
        .el-textarea__inner:focus{
            border: 1px solid #ddd;
            background: #f7f7f7;
            transition: 0.4s;
        }

        /* mxPopuMenu */
        div.mxPopupMenu{
            -webkit-box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1)!important;
            -moz-box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1)!important;
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1)!important;
            border: unset!important;
        }
        
        /* mxToolTip */
        div.mxTooltip {
            background: #fff;
            border: unset!important;
            font-family: inherit;
            font-size: 12px;
            padding: 10px;
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
        }

        /* graph background pattern */
        .topological-graph-component #graphContainer > svg.grid-pattern{
            background:
                linear-gradient(-90deg, rgba(0,0,0,.05) 1px, transparent 1px),
                linear-gradient(rgba(0,0,0,.05) 1px, transparent 1px), 
                linear-gradient(-90deg, rgba(0, 0, 0, .04) 1px, transparent 1px),
                linear-gradient(rgba(0,0,0,.04) 1px, transparent 1px),
                linear-gradient(transparent 3px, #f2f2f2 3px, #f2f2f2 78px, transparent 78px),
                linear-gradient(-90deg, #aaa 1px, transparent 1px),
                linear-gradient(-90deg, transparent 3px, #f2f2f2 3px, #f2f2f2 78px, transparent 78px),
                linear-gradient(#aaa 1px, transparent 1px),
                #f2f2f2;
            background-size:
                4px 4px,
                4px 4px,
                80px 80px,
                80px 80px,
                80px 80px,
                80px 80px,
                80px 80px,
                80px 80px;
        }

        /* note background */
        .topological-view-diagnosis .notes-view-content {
            height: calc(100% - 45px)!important;
            background: #f9f9f5;
        }

        /* edge flow Effect */
        .topological-graph-component .flow {
		  stroke-dasharray: 8;
		  animation: dash 0.5s linear;
		  animation-iteration-count: infinite;
		}
		@keyframes dash {
		  to {
		    stroke-dashoffset: -16;
		  }
		}
    }

	</style>

	
	/*----------  最外层element会自动增加组件同名 class="topological-graph-component"  ----------*/
	<template>
		<el-main style="overflow:hidden;padding: 0px;width:100%;height:100%;">
            <el-container id="container" style="width:100%;height:100%;position: relative;" ref="container" direction="vertical">
                <el-header style="height:35px;line-height: 35px;padding:0px;position: relative;display:none;">
                    <graph-view-search class="tools-search" ref="graphViewSearch"></graph-view-search>
                </el-header>
                <el-main id="graphContainer" ref="graphContainer" 
                        style="width:100vw;height:100vh;min-width:100vw;position:releative;overflow:hidden;padding:0px;">
                </el-main>
                <el-footer class="footerbar" ref="footer" v-if="model.graph.footbar.show">
                    <topological-timeline :model="model.graph.allNodesIds" ref="timeline"></topological-timeline>
                </el-footer>
                <div id="search-toolbar" class="search-toolbar">
                    <topological-search-toolbar ref="searchToolbar" style="width:100%;"></topological-search-toolbar>
                </div>
                <div id="controlBar" class="controlBar">
                    <el-tooltip content="切换显示工具栏" open-delay="500">
                        <el-button type="text" icon="el-icon-menu" @click="model.control.show=!model.control.show"></el-button>
                    </el-tooltip>
                </div>
                <div id="outlineContainer" class="outlineContainer animated fadeIn" v-show="model.control.show"></div>
                <div class="vertical-toolbar animated fadeIn" v-show="model.control.show">
                    <el-popover
                        placement="left"
                        title="信息"
                        width="300"
                        trigger="click"
                        popper-class="info-popper">
                        <el-card>
                            <el-divider content-position="left">实体类型</el-divider>
                            <div style="display:flex;flex-wrap: wrap; align-items: flex-start;margin:10px 0px;">
                                <el-tag type="default" 
                                    :key="v" v-for="v in model.graph.allNodesClass" 
                                    style="margin:5px;width:auto;cursor:pointer;"
                                    effect="plain" 
                                    @click="onTagClick($event,'vertex',v)">
                                    ${v}
                                </el-tag>
                            </div>
                            <el-divider content-position="left">关系</el-divider>
                            <div style="display:flex;flex-wrap: wrap; align-items: flex-start;margin:10px 0px;">
                                <el-tag type="default" 
                                    :key="v" v-for="v in allEdges" 
                                    style="margin:5px;width:auto;cursor:pointer;"
                                    effect="plain" 
                                    @click="onTagClick($event,'edge',v)">
                                    ${v}
                                </el-tag>
                            </div>
                        </el-card>
                        <el-button type="text" slot="reference">
                            <i class="el-icon-postcard" style="font-size:18px;margin:0 5px;">
                        </el-button>
                    </el-popover>
                    <el-divider></el-divider>
                    <el-tooltip content="放大" open-delay="500" placement="left">
                       <el-button type="text"  @click="onZoomIn">
                            <i class="el-icon-zoom-in" style="font-size:18px;">
                       </el-button>
                   </el-tooltip>
                   <el-divider></el-divider>
                   <el-tooltip content="缩小" open-delay="500" placement="left">
                       <el-button type="text"  @click="onZoomOut">
                            <i class="el-icon-zoom-out" style="font-size:18px;">
                       </el-button>
                   </el-tooltip>
                   <el-divider></el-divider>
                   <el-tooltip content="将图居中显示"" open-delay="500" placement="left">
                       <el-button type="text"  @click="toCenter">
                            <i class="el-icon-rank" style="font-size:18px;">
                       </el-button>
                   </el-tooltip>
                   <el-divider></el-divider>
                   <el-tooltip content="节点渲染模式" open-delay="500" placement="left">
                        <el-button type="text" :icon="model.control.ifIcon | pickIconStyle" @click="onToggleIcon" style="width:18px;height:auto;">
                        </el-button>
                    </el-tooltip>
                   <el-divider></el-divider>
                   <el-tooltip content="全屏显示" open-delay="500" placement="left">
                       <el-button type="text" :icon="model.control.ifFullScreen | pickScreenStyle" 
                                @click="onFullScreen" style="width:18px;height:auto;">
                       </el-button>
                   </el-tooltip>
                   <el-divider></el-divider>
                   <el-tooltip content="调整布局" open-delay="500" placement="left">
                       <el-dropdown @command="onSetLayout">
                           <span class="el-dropdown-link">
                                <i class="el-icon-view" style="font-size:18px;">
                           </span>
                           <el-dropdown-menu slot="dropdown">
                               <el-dropdown-item :command="{name:'hierarchical',value:4}">分层</el-dropdown-item>
                               <el-dropdown-item :command="{name:'tree',value:null}">树形</el-dropdown-item>
                               <el-dropdown-item :command="{name:'organic',value:null}">随机</el-dropdown-item>
                               <el-dropdown-item :command="{name:'circle',value:null}">圆形</el-dropdown-item>
                           </el-dropdown-menu>
                       </el-dropdown>
                   </el-tooltip>
                   <el-divider></el-divider>
                   <el-tooltip content="打印" open-delay="500" placement="left">
                       <el-button type="text"  @click="onPrint">
                           <i class="el-icon-printer" style="font-size:18px;">
                       </el-button>
                   </el-tooltip>
                   <el-divider></el-divider>
                   <el-tooltip content="调整图背景" open-delay="500" placement="left">
                       <el-color-picker
                           v-model="model.graph.theme.color"
                           :predefine="model.graph.theme.predefineColors"
                           @change="setTheme"
                           style="padding:4px 8px;">
                       </el-color-picker>
                   </el-tooltip>
                   <el-divider></el-divider>
                   <el-tooltip content="时间轴" open-delay="500" placement="left">
                        <el-button type="text"  @click="onTimeLine">
                            <i :class="['animated fadeIn ', model.graph.footbar.show ? 'el-icon-d-arrow-right' : 'el-icon-d-arrow-left']"></i>
                        </el-button>
                    </el-tooltip>
               </div>
               
               <el-dialog
                    title="实体/关系编辑"
                    :visible.sync="entity.dialog.show"
                    width="60%"
                    modal="false"
                    @closed="onEntityDialogClosed">
                    <el-row :gutter="24">
                        <el-col :span="8">
                            <h4>起始点</h4>
                            <el-form label-width="80" v-if="entity.source">
                                <el-form-item label="id">
                                    <el-input v-model="entity.source.id" placeholder="ID" disabled></el-input>
                                </el-form-item>
                                <el-form-item label="value">
                                    <el-input v-model="entity.source.value" placeholder="Value"  disabled></el-input>
                                </el-form-item>
                            </el-form>
                        </el-col>
                        <el-col :span="8">
                            <h4>选择关系</h4>
                            <el-select v-model="entity.edges.value" placeholder="选择关系类型">
                              <el-option v-for="item in entity.edges.list" 
                                :key="item.name"
                                :value="item.name"
                                :label="item.remedy"></el-option>
                            </el-select>
                        </el-col>
                        <el-col :span="8">
                            <h4>目标点</h4>
                            <el-form label-width="80" v-if="entity.target">
                                <el-form-item label="id">
                                    <el-input v-model="entity.target.id" placeholder="ID"></el-input>
                                </el-form-item>
                                <el-form-item label="name" v-if="!entity.target.type">
                                    <el-input v-model="entity.target.value" placeholder="Value"></el-input>
                                </el-form-item>
                            </el-form>
                        </el-col>
                      </el-row>
                    <span slot="footer" class="dialog-footer">
                        <el-button @click="entity.dialog.ifClose = true;entity.dialog.show = false;">取消</el-button>
                        <el-button type="primary" @click="addEntity(null)" v-if="entity.target.type=='new'">创建实体和关系</el-button>
                        <el-button type="primary" @click="updateEntityEdge" v-else>创建关系</el-button>
                    </span>
                </el-dialog>

                <el-dialog
                    title="新建实体"
                    :visible.sync="entity.newDialog.show"
                    width="60%"
                    height="50vh"
                    modal="false"
                    @closed="onEntityDialogClosed">
                    <mx-entity-new></mx-entity-new>
                </el-dialog>

                <el-dialog
                    title="新建关系类型"
                    :visible.syc="entity.newEdgeType.show"
                    width="60%"
                    height="50vh"
                    modal="false"
                    @closed="entity.newEdgeType.show=false">
                    <el-form :model="entity.newEdgeType.model">
                        <el-form-item label="类型名称(Name)" label-width="120px">
                          <el-input v-model="entity.newEdgeType.model.name" autocomplete="off"></el-input>
                        </el-form-item>
                        <el-form-item label="类型描述(Remedy)" label-width="120px">
                            <el-input v-model="entity.newEdgeType.model.remedy" autocomplete="off"></el-input>
                        </el-form-item>
                      </el-form>
                      <div slot="footer" class="dialog-footer">
                        <el-button @click="entity.newEdgeType.show = false">取 消</el-button>
                        <el-button type="primary" @click="onSaveEdgeType">确 定</el-button>
                      </div>
                </el-dialog>
            </el-container>
		</el-main>
	</template>

	/*----------  id是vue组件的name，内容是vue组件的option参数  ----------*/
	<script id="topological-graph-component">
	{
	    delimiters: ['${', '}'],
	    props: {
	        graphData: Object
	    },
	    data() {
            
            return {
                id: _.now(),
                model:{
                    editor: null,
                    graph:{
                        container: null,
                        model: null,
                        graph: null,
                        parent: null,
                        outline: null,
                        layout: {
                            default: "hierarchical",
                            inst: null,
                            edgeStyle: "4"
                        },
                        allNodesIds: [],
                        allNodesClass: [],
                        nodes:null,
                        edges:null,                        
                        path: {
                            list:[],
                            colors:['#ff0000','#ffd700','#666666','#00ffff','#40e0d0','#ff7373','#d3ffce','#3399ff','#000080','#66cccc','#a0db8e','#794044','#6897bb','#cc0000'],
                        },
                        default: {
                            title: 'name',
                            list: []
                        },
                        theme:{
                            color: "#FFFFFF",
                            predefineColors: [
                                                '#ffffff',
                                                '#f7f7f7',
                                                '#dddddd',
                                                '#e7e7e7',
                                                '#c7c7c7',
                                                '#6b778d',
                                                '#263859',
                                                '#17223b',
                                                '#333333',
                                                '#D3FFF4',
                                                '#EBDCF4',
                                                '#B3C0FD',
                                                '#AE8BB5',
                                                '#736D6D'
                                                ]
                        },
                        history:[],
                        footbar:{
                            show: false
                        },
                        show: {
                            type: "image"
                        }
                    },
                    control: {
                        ifFullScreen: false,
                        ifIcon: true,
                        show: true,
                        checkedNodes:[],
                        checkedEdges:[],
                        refresh:{
                            inst: null,
                            enable: true,
                            interval: 15*1000
                        }
                    }
                },
                entity: {
                    dialog: {
                        show: false,
                        ifClose: false,
                        classList: fsHandler.callFsJScript("/matrix/omdb/getClassListForTree.js",encodeURIComponent("/matrix/entity")).message,
                        defaultProps: {
                            children: 'children',
                            label: 'class'
                        }
                    },
                    newDialog:{
                        show: false,
                        tree: {

                        },
                        model:{
                            id:"",
                            name:"",
                            class: ""
                        }
                    },
                    newEdgeType: {
                        show:false,
                        model: {
                            name:"",
                            remedy: ""
                        }
                    },
                    source: {},
                    target: {},
                    edges: {
                        value: "",
                        list: fsHandler.callFsJScript("/matrix/graph/edges.js",null).message
                    }
                },
                layout: {
                    splitInst: null
                },
                global: {
                    count: 0
                }
	        }
        },
        filters: {
            genFileName(event){
                return `${window.ASSETS_ICON}/tools/png/${event}.png?type=open&issys=${window.SignedUser_IsAdmin}`;
            },
            pickScreenStyle(evt){
                if(evt){
                    return `el-icon-full-screen`;
                } else {
                    return `el-icon-copy-document`;
                }
            },
            pickIconStyle(evt){
                if(evt){
                    return `el-icon-picture-outline`;
                } else {
                    return `el-icon-s-help`;
                }
            }
        },
        computed: {
            allNodes(){
                try{
                    let cells = this.model.editor.graph.getChildVertices(this.model.editor.graph.getDefaultParent());
                    return  _.uniq(_.map(cells,(v,k)=>{
                                return v.getId().split(":")[0];
                            })).sort();
                } catch(err){
                    return [];
                }

            },
            allEdges(){
                try{
                    return  _.uniq(_.map(this.model.graph.edges,(v,k)=>{
                                return v.getValue();
                            })).sort();
                } catch(err){
                    return [];
                }
            }
        },
	    watch:{
	        graphData:{
                handler:function(val,oldVal){
                    
                    if(_.isEmpty(val.nodes)){
                        this.$message({
                            type: "info",
                            message: "没有匹配的实体图谱"
                        })

                        this.onClear();

                        return false;
                    }

                    if(val === oldVal){
                        return false;
                    } else {
                        this.onReload();
                    }
                },
                deep:true
            },
            'model.graph.allNodesIds': {
                handler:function(val,oldVal) {
                    this.model.graph.allNodesClass = _.uniq(_.map(val,(v)=>{
                            return v.split(":")[0];
                        })).sort();
                },
                immediate: true
            },
            'model.control.refresh.enable':{
                handler(val,oldVal){
                    if(val) {
                        this.model.control.refresh.inst = setInterval(()=>{
                            this.refreshEntityStatus();
                        },this.model.control.refresh.interval);
                        this.$message({
                            type: "info",
                            message: "自动刷新开启"
                        })
                    } else {
                        clearInterval(this.model.control.refresh.inst);
                        this.$message({
                            type: "info",
                            message: "自动刷新关闭"
                        })
                    }
                },
                deep:true
            },
            'model.graph.footbar.show':function(val,oldVal){
                if(val){
                    this.model.control.show = !this.model.control.show;
                }
            }
        },
        created(){

            // 状态刷新频率
            this.model.control.refresh.interval = mx.global.register.topological.status_interval;

            eventHub.$on(`PATH-TOGGLE-EVENT-${this.id}-graph-path`,this.addPath);

            eventHub.$on("TOPOLOGICAL-ANALYSIS-CALLBACK", this.removePath);
            
            //初始化theme
            this.model.graph.theme.color = localStorage.getItem(`GRAPH-VIEW-THEME-${window.SignedUser_UserName}`);

            // 节点渲染方式
            this.model.control.ifIcon = (localStorage.getItem("TOPOLOGICAL-RENDER-TYPE"))=='true'?true:false;
            // 关系渲染类型
            this.model.graph.layout.edgeStyle = localStorage.getItem("TOPOLOGICAL-RENDER-EDGESTYLE") || 4;

            // 节点是否可以移动 
            mxGraphHandler.prototype.setMoveEnabled(true);
            //显示节点位置标尺  
            mxGraphHandler.prototype.guidesEnabled = true;

            // Alt disables guides
            mxGuide.prototype.isEnabledForEvent = function(evt){
                return !mxEvent.isAltDown(evt);
            };

            // Enables snapping waypoints to terminals
            mxEdgeHandler.prototype.snapToTerminals = true;

            // Defines an icon for creating new connections in the connection handler.
            // This will automatically disable the highlighting of the source vertex.
            mxConnectionHandler.prototype.connectImage = new mxImage('/fs/assets/images/tools/down.gif?type=open&issys=true', 16, 16);

            // Sets the collapse and expand icons. The values below are the default
            // values, but this is how to replace them if you need to.
            mxGraph.prototype.collapsedImage = new mxImage('/fs/assets/images/graph/tools/collapsed.gif?type=open&issys=true', 9, 9);
            mxGraph.prototype.expandedImage = new mxImage('/fs/assets/images/graph/tools/expanded.gif?type=open&issys=true', 9, 9);
        
        },
        mounted() {
	        
	        this.$nextTick(()=>{

                _.delay(()=>{
                    
                    // 初始化
                    this.init();
                    
                    // 鹰眼
                    this.outline();

                    _.delay(()=>{
                        // 设置主题
                        this.setTheme(this.model.graph.theme.color);
                        // 初始化ToolBar
                        this.nodeTitle();
                    },500)

                    // 初始化滚轮图缩放事件监听
                    this.addScrollListener(this.model.graph.container, this.wheelHandle);
                },500)
	            
	        })
        },
	    methods: {
            init() {
                
                if (!mxClient.isBrowserSupported()){
                    mxUtils.error('Browser is not supported!', 200, false);
                } else {
                    
                    this.model.graph.container = document.getElementById(this.$refs.graphContainer.$el.id);
                    
                    // Workaround for Internet Explorer ignoring certain CSS directives
                    if (mxClient.IS_QUIRKS) {
                        document.body.style.overflow = 'hidden';
                        new mxDivResizer(this.model.graph.container);
                    }

                    // 初始化Graph
                    this.model.editor = new mxEditor();
                    //this.model.editor.graph = new mxGraph(this.model.graph.container);

                    // Sets the graph container and configures the editor
                    this.model.editor.setGraphContainer(this.model.graph.container);

                    this.model.graph.parent = this.model.editor.graph.getDefaultParent();

                    this.model.editor.graph.setEnabled(true);
                    // 设定可连接
                    this.model.editor.graph.setConnectable(true);
                    // 容器大小自适应 
                    this.model.editor.graph.setResizeContainer(false);

                    // Clones the source if new connection has no target
                    this.model.editor.graph.connectionHandler.setCreateTarget(true);
                    
                    this.model.editor.graph.setConnectableEdges(false);
                    this.model.editor.graph.setDropEnabled(true);

                    // 是否允许平移。true：表示按住Shift+左键拖动时，整个graph移动；
                    // false：按住Shift+左键拖动时，选中的图形水平方向或者垂直方向平移。
                    this.model.editor.graph.setPanning(true);
                    mxPanningHandler.prototype.isPanningTrigger = function(me) {
                        var evt = me.getEvent();
                        return true;
                    };

                    // 禁止改变节点大小
                    this.model.editor.graph.setCellsResizable(false);
                    // 禁止节点文字编辑功能
                    this.model.editor.graph.setCellsEditable(false);
                    
                    // 禁止连线移动
                    this.model.editor.graph.disconnectOnMove = false;
                    

                    // 允许连线的目标和源是同一元素 
                    this.model.editor.graph.setAllowLoops(true); 
                    // 居中缩放
                    this.model.editor.graph.centerZoom = true;
                    // Tooltips on touch devices
                    this.model.editor.graph.setTooltips(!mxClient.IS_TOUCH);
                    // 支持Html
                    this.model.editor.graph.setHtmlLabels(true);


                    // 鼠标框选
                    new mxRubberband(this.model.editor.graph);

                    // Sets global styles
                    var style = this.model.editor.graph.getStylesheet().getDefaultEdgeStyle();
                    style[mxConstants.STYLE_EDGE] = mxEdgeStyle.EntityRelation;
                    style[mxConstants.STYLE_ROUNDED] = true;

                    style = this.model.editor.graph.getStylesheet().getDefaultVertexStyle();
                    style[mxConstants.STYLE_FILLCOLOR] = '#2f8ee7';
                    style[mxConstants.STYLE_FONTCOLOR] = '#333333';
                    style[mxConstants.STYLE_FONTSIZE] = '14';
                    style[mxConstants.STYLE_SHAPE] = 'swimlane';
                    style[mxConstants.STYLE_SPACING] = '10';
                    style[mxConstants.STYLE_STARTSIZE] = 30;
                    style[mxConstants.STYLE_GRADIENTCOLOR] = 'blue';

                    style = [];
                    style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
                    style[mxConstants.STYLE_STROKECOLOR] = 'none';
                    style[mxConstants.STYLE_FILLCOLOR] = 'none';
                    style[mxConstants.STYLE_FOLDABLE] = false;
                    style = this.model.editor.graph.getStylesheet().putCellStyle('column', style);

                    // 预览时鼠标悬浮到节点时，改变鼠标样式
                    this.model.editor.graph.getCursorForCell = function(cell){
                        if (cell != null && cell.value != null && cell.vertex ==1 ){
                            return 'pointer';
                        }
                    }
                    
                    new mxCellTracker(this.model.editor.graph);
                    
                    // 布局定义
                    this.executeLayout();

                    // Animates the changes in the graph model
                    // this.model.editor.graph.getModel().addListener(mxEvent.CHANGE, (sender, evt)=>{
                    //     var changes = evt.getProperty('edit').changes;
                    //     mxEffects.animateChanges(this.model.editor.graph, changes);
                    // });

                    // Installs a popupmenu handler using local function (see below).
                    const self = this;
                    // 首先禁用浏览器右键菜单
                    mxEvent.disableContextMenu(this.$el);
                    // 右键菜单
                    //this.model.editor.graph.popupMenuHandler.autoExpand = true;
                    this.model.editor.graph.popupMenuHandler.factoryMethod = function(menu, cell, evt){
                        self.createPopupMenu(self.model.editor, self.model.editor.graph, menu, cell, evt);
                    };

                    this.initGraph();
                    this.graphEvent(this.model.editor.graph);

                }
            },
            addScrollListener(element, wheelHandle) {
                if (typeof element != 'object') return;
                if (typeof wheelHandle != 'function') return;

                // 监测浏览器
                if (typeof arguments.callee.browser == 'undefined') {
                    var user = navigator.userAgent;
                    var b = {};
                    b.opera = user.indexOf("Opera") > -1 && typeof window.opera == "object";
                    b.khtml = (user.indexOf("KHTML") > -1 || user.indexOf("AppleWebKit") > -1 || user.indexOf("Konqueror") > -1) && !b.opera;
                    b.ie = user.indexOf("MSIE") > -1 && !b.opera;
                    b.gecko = user.indexOf("Gecko") > -1 && !b.khtml;
                    arguments.callee.browser = b;
                }
                if (element == window)
                    element = document;
                if (arguments.callee.browser.ie)
                    element.attachEvent('onmousewheel', wheelHandle);
                else
                    element.addEventListener(arguments.callee.browser.gecko ? 'DOMMouseScroll' : 'mousewheel', wheelHandle, false);
            },
            wheelHandle(e) {
                var upcheck;

                if (e.wheelDelta) {
                    upcheck = e.wheelDelta > 0 ? 1 : 0;
                } else {
                    upcheck = e.detail < 0 ? 1 : 0;
                }
                if (upcheck) {
                    this.model.editor.graph.zoomIn();
                }
                else {
                    this.model.editor.graph.zoomOut();
                }

                if (window.event) {
                    e.returnValue = false;
                    window.event.cancelBubble = true;
                } else {
                    e.preventDefault();
                    e.stopPropagation();
                }
            },
            createPopupMenu(editor, graph, menu, cell, evt){
                // node/edge menu
                if (cell != null){
                    // node
                    let id = cell.getId();
                    let value = cell.getValue();
                    let node = {id: id, value: value, type:'event', cell: cell};

                    // node
                    if(!cell.edge){

                        menu.addItem('实体分析', null, ()=>{
                            this.$root.$refs.graphDiagnosisRef.diagnosisAdd( node );
                        });

                        menu.addItem('实体删除', null, ()=>{
                            this.removeEntity(cell);
                        });
                        
                        menu.addSeparator();

                        var submenuBsearch= menu.addItem('起点图查询', null, null);
                        menu.addItem('1跳', null, ()=>{
                            this.loadSubGraph({direction:"out",node:node,step:1});
                        },submenuBsearch);
                        menu.addItem('2跳', null, ()=>{
                            this.loadSubGraph({direction:"out",node:node,step:2});
                            
                        },submenuBsearch);
                        menu.addItem('3跳', null, ()=>{
                            this.loadSubGraph({direction:"out",node:node,step:3});
                        },submenuBsearch);
                        menu.addItem('4跳', null, ()=>{
                            this.loadSubGraph({direction:"out",node:node,step:4});
                        },submenuBsearch);
                        menu.addItem('5跳', null, ()=>{
                            this.loadSubGraph({direction:"out",node:node,step:5});
                        },submenuBsearch);
                        menu.addItem('6跳', null, ()=>{
                            this.loadSubGraph({direction:"out",node:node,step:6});
                        },submenuBsearch);

                        var submenuEsearch= menu.addItem('终点图查询', null, null);
                        menu.addItem('1跳', null, ()=>{
                            this.loadSubGraph({direction:"in",node:node,step:1});
                        },submenuEsearch);
                        menu.addItem('2跳', null, ()=>{
                            this.loadSubGraph({direction:"in",node:node,step:2});
                        },submenuEsearch);
                        menu.addItem('3跳', null, ()=>{
                            this.loadSubGraph({direction:"in",node:node,step:3});
                        },submenuEsearch);
                        menu.addItem('4跳', null, ()=>{
                            this.loadSubGraph({direction:"in",node:node,step:4});
                        },submenuEsearch);
                        menu.addItem('5跳', null, ()=>{
                            this.loadSubGraph({direction:"in",node:node,step:5});
                        },submenuEsearch);
                        menu.addItem('6跳', null, ()=>{
                            this.loadSubGraph({direction:"in",node:node,step:6});
                        },submenuEsearch);

                        menu.addSeparator();

                        menu.addItem('关系维护', null, ()=>{
                            this.$root.$refs.graphEdgesRef.edgesTabAdd( node );
                        });

                        menu.addSeparator();

                        menu.addItem('选定为路径查询点', null, ()=>{
                            if(this.$refs.searchToolbar.currentView==='topological-search-toolbar-graphAdv'){
                                this.$refs.searchToolbar.currentView = "topological-search-toolbar-path";
                            }
                            _.delay(()=>{
                                eventHub.$emit("TOPOLOGICAL-ANALYISS-TRACE", node);
                            },500)
                        });

                        menu.addSeparator();

                        // menu.addItem('撤销', null, ()=>{
                        //     this.model.editor.execute('undo');
                        // });
                        // menu.addItem('重做', null, ()=>{
                        //     this.model.editor.execute('redo');
                        // });

                        // menu.addSeparator();
                        
                        menu.addItem('节点隐藏', null, ()=>{
                            // graph action
                            // cell.removeFromParent();
                            // this.model.editor.graph.refresh(cell);
                            graph.removeCells([cell]);
							mxEvent.consume(evt);
                        });

                        menu.addItem('节点删除', null, ()=>{
                            // graph action
                            graph.removeCells([cell]);
							mxEvent.consume(evt);
                        });


                    } 
                    // edge
                    else {
                        menu.addItem('实体关系分析', null, ()=>{
                            this.$root.$refs.graphDiagnosisRef.diagnosisAdd( node );
                        });

                        menu.addItem('实体关系删除', null, ()=>{
                            this.$root.$refs.graphViewRef.$refs.graphViewContainerInst.removeEntity(cell);
                        });
                    }
                } 
                // container menu
                else {
                    

                    if(!_.isEmpty(this.graphData.nodes)){
                        menu.addItem('刷新', null, ()=>{
                            this.onReload();
                        });
                    }
                    
                    let cells = this.model.editor.graph.getChildVertices(this.model.editor.graph.getDefaultParent())
                    if(!_.isEmpty(cells)){
                        menu.addItem('清空', null, ()=>{
                            this.onClear();
                        });
                    }

                    menu.addSeparator();

                    menu.addItem('撤销', null, ()=>{
                        this.model.editor.execute("undo");
                    });
                    menu.addItem('重做', null, ()=>{
                        this.model.editor.execute("redo");
                    });
                    menu.addSeparator();

                    var submenuEntity = menu.addItem('实体', null, null);
                    menu.addItem('新建实体', null, ()=>{
                        this.entity.newDialog.show = true;
                    }, submenuEntity);
                    menu.addItem('新建关系类型', null, ()=>{
                        this.entity.newEdgeType.show = true;
                    }, submenuEntity);
                    
                    menu.addSeparator();

                    var submenuIcon = menu.addItem('显示', null, null);
                    
                    menu.addItem('图标', null, ()=>{
                        this.model.control.ifIcon = true;
                        localStorage.setItem("TOPOLOGICAL-RENDER-TYPE",this.model.control.ifIcon);
                        this.onReload();
                    }, submenuIcon);
                    menu.addItem('图形', null, ()=>{
                        this.model.control.ifIcon = false;
                        localStorage.setItem("TOPOLOGICAL-RENDER-TYPE",this.model.control.ifIcon);
                        this.onReload();
                    }, submenuIcon);

                    menu.addSeparator();

                    var submenuLabel = menu.addItem("标签",null,null);
                    _.forEach(this.model.graph.default.list,(v)=>{
                        menu.addItem(v.label, null, ()=>{
                            this.model.graph.default.title = v.label;
                            this.onReload();
                        }, submenuLabel);
                    })

                    menu.addSeparator();
                    
                    var submenuLayout = menu.addItem('布局', null, null);

                    var submenuLayoutHierarchical = menu.addItem('分层布局', null, null,submenuLayout);
                    menu.addItem('折线', null, ()=>{
                        this.model.graph.layout.default = 'hierarchical';
                        this.model.graph.layout.edgeStyle = 2;
                        this.executeLayout();
                        localStorage.setItem("TOPOLOGICAL-RENDER-EDGESTYLE",this.model.graph.layout.edgeStyle);
                    }, submenuLayoutHierarchical);
                    menu.addItem('直线', null, ()=>{
                        this.model.graph.layout.default = 'hierarchical';
                        this.model.graph.layout.edgeStyle = 3;
                        this.executeLayout();
                        localStorage.setItem("TOPOLOGICAL-RENDER-EDGESTYLE",this.model.graph.layout.edgeStyle);
                    }, submenuLayoutHierarchical);
                    menu.addItem('圆角', null, ()=>{
                        this.model.graph.layout.default = 'hierarchical';
                        this.model.graph.layout.edgeStyle = 4;
                        this.executeLayout();
                        localStorage.setItem("TOPOLOGICAL-RENDER-EDGESTYLE",this.model.graph.layout.edgeStyle);
                    }, submenuLayoutHierarchical);
                    
                    
                    var submenuLayoutTree = menu.addItem('树形布局', null, null,submenuLayout);

                    menu.addItem('上下', null, ()=>{
                        this.model.graph.layout.default = 'tree_vertical';
                        this.executeLayout();
                    }, submenuLayoutTree);
                    menu.addItem('左右', null, ()=>{
                        this.model.graph.layout.default = 'tree_horizontal';
                        this.executeLayout();
                    }, submenuLayoutTree);

                    menu.addItem('随机布局', null, ()=>{
                        this.model.graph.layout.default = 'organic';
                        this.executeLayout();
                    }, submenuLayout);
                    menu.addItem('圆形布局', null, ()=>{
                        this.model.graph.layout.default = 'circle';
                        this.executeLayout();
                    }, submenuLayout);

                    menu.addSeparator();

                    var submenuGraph = menu.addItem('画布',null,null);
                    menu.addItem('无', null, ()=>{
                        $("#graphContainer>svg").removeClass("grid-pattern");
                    }, submenuGraph);
                    menu.addItem('格子', null, ()=>{
                        $("#graphContainer>svg").addClass("grid-pattern");
                    }, submenuGraph);
                }
                
            },
            checkImgExists(name){
                let term = {parent:"/assets/images/entity/png", name:name};
                return fsHandler.callFsJScript("/matrix/graph/checkHaveFile.js", encodeURIComponent(JSON.stringify(term))).message;
            },
            initGraph(){
                
                let allNodes = [];
                let allEdges = [];

                this.model.editor.graph.getModel().beginUpdate();
                
                try{

                    if(!_.isEmpty(window.URL_PARAMS_ITEM)) {
                        let doc = mxUtils.parseXml(this.graphData);
                        let svgBgColor = doc.getElementsByTagName("mxGraphModel")[0].getAttribute("background") || "#ffffff";
                        $("svg", this.$el).css("background-color",svgBgColor);
                        let codec = new mxCodec(doc);

                        codec.decode(doc.documentElement, this.model.editor.graph.getModel());

                        $("foreignObject div").css("color","#849EB6");
                    } else {
                        
                        this.model.editor.graph.getModel();
                        this.model.graph.nodes = {};
                        
                        // 添加节点类型，是否是新增、删除或者正常
                        allNodes =  _.map(this.graphData.nodes,(v)=>{
                                            return _.extend(v,{type:'normal'});
                                    });
                        
                        //合并新增节点
                        try{
                            allNodes = _.extend(allNodes,_.map(this.graphData.diff.add.nodes,(v)=>{
                                return _.extend(v,{type:'add'});
                            }))
                        }catch(err){
                            
                        }
                        
                        //合并删除的节点
                        try{
                            allNodes =  _.concat(allNodes,_.map(this.graphData.diff.del.nodes,(v)=>{
                                            return _.extend(v,{type:'del'});
                                        }))
                        } catch(err){
                            
                        }

                        // 添加edge类型，包括正常的、新增的、删除的
                        allEdges = _.map(this.graphData.edges,(v)=>{
                            return _.extend(v,{type:"normal"});
                        });

                        //合并新增edge
                        try{
                            allEdges = _.map(allEdges,(v)=> {
                                if(_.find(this.graphData.diff.add.edges,{id:v.id})){
                                    return _.extend(v,{type:'add'});
                                } else {
                                    return v;
                                }
                            });
                        }catch(err){

                        }
                        
                        // 合并删除edge
                        try {
                            allEdges =  _.concat(allEdges,_.map(this.graphData.diff.del.edges,(v)=> {
                                            return _.extend(v,{type:'del'});
                                        }));
                        } catch(err){
                            
                        }

                        // 绘制节点
                        _.forEach(allNodes,(v)=>{

                            let _type = v._icon || 'matrix';
                            
                            // 可设置默认显示属性
                            let _name =  '';
                            
                            try{
                                if(window.URL_PARAMS_GRAPH){
                                    _name = v[window.URL_PARAMS_GRAPH.title];
                                } else {
                                    _name = v[this.model.graph.default.title];
                                }
                            } catch(err){
                                _name = v["id"];
                            }

                            // normal
                            // 选择节点渲染模式：icon/shape
                            let node = null;
                            let imageUrl = `${window.ASSETS_ICON}/entity/png/${_type}.png?type=download&issys=${window.SignedUser_IsAdmin}`;
                            
                            // icon渲染
                            if(this.model.control.ifIcon){
                                if(this.checkImgExists(`${_type}.png`)){
                                    node = this.model.editor.graph.insertVertex(this.model.graph.parent, v.id, _name, 50, 50, 60, 60,`shape=image;html=1;image=${imageUrl};verticalLabelPosition=bottom;verticalAlign=top;`);
                                } else {
                                    node = this.model.editor.graph.insertVertex(this.model.graph.parent, v.id, _name, 50, 50, 50, 50,`shape=ellipse;perimeter=ellipsePerimeter;html=1;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=middle;`);
                                }    
                            } 
                            // shape渲染
                            else {
                                node = this.model.editor.graph.insertVertex(this.model.graph.parent, v.id, _name, 50, 50, 50, 50,`shape=ellipse;perimeter=ellipsePerimeter;html=1;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=middle;`);
                            }

                            

                            // node directory
                            _.extend(this.model.graph.nodes,{[v.id]:node});


                            //add
                            if(v.type && v.type === 'add'){
                                let overlay = new mxCellOverlay(new mxImage(`/fs/assets/images/apps/png/flag/add.png?issys=true&type=download`,24,24), "新增", mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_TOP, new mxPoint(-10,15));
                                this.model.editor.graph.addCellOverlay(node, overlay);
                            }

                            //delete
                            if(v.type && v.type === 'del'){
                                let overlay = new mxCellOverlay(new mxImage(`/fs/assets/images/apps/png/flag/delete.png?issys=true&type=download`,24,24), "删除", mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_TOP, new mxPoint(-10,15));
                                this.model.editor.graph.addCellOverlay(node, overlay);
                            }

                        })

                        // 边界
                        this.model.graph.edges = {};
                        _.forEach(allEdges,(k,index)=>{
                            
                            let source = this.model.graph.nodes[k.source];
                            let target = this.model.graph.nodes[k.target];

                            let baseEdgeStyle = 'edgeStyle=elbowEdgeStyle;html=1;rounded=1;jettySize=auto;orthogonalLoop=1;endArrow=block;endFill=1;';
                            let direction = '';

                            if(k.twoway){
                                direction = 'startArrow=block;endArrow=block;endFill=1;';
                            }

                            if(k.type=='add'){
                                direction += 'strokeColor=#47fa28;strokeWidth=2;';
                            } else if(k.type=='del'){
                                direction += 'dashed=1;strokeColor=#ff0000;strokeWidth=2;';
                            } else {
                                direction += ''; 
                            }

                            // edge为path的样式
                            if(k.class === "path"){
                                baseEdgeStyle = 'edgeStyle=elbowEdgeStyle;orthogonalLoop=1;strokeWidth=1;dashed=1;startFill=0;endArrow=none;endFill=0;startArrow=none;orthogonal=1;elbow=vertical;';
                                let strokeColor = this.model.graph.path.colors[index] || _.sample(this.model.graph.path.colors);
                                let edge = this.model.editor.graph.insertEdge(this.model.graph.parent, k.id, k.class, source, target, baseEdgeStyle+direction+`strokeColor=${strokeColor}`);
                                return;
                            }

                            let edge = null;
                            try {
                                let edgeName = _.find(allEdges,{name:k.class}).remedy;
                                edge = this.model.editor.graph.insertEdge(this.model.graph.parent, k.id, edgeName, source, target, baseEdgeStyle+direction);
                            } catch(err){
                                edge = this.model.editor.graph.insertEdge(this.model.graph.parent, k.id, k.class, source, target, baseEdgeStyle+direction);
                            }
                            
                            // edge directory
                            try{
                                let id = source.getId() + ':' + target.getId();
                                _.extend(this.model.graph.edges, { [id]: edge });
                            } catch(err){
                                console.log(err)
                            }
                            
                        })


                    }

                    // Executes the layout handler
                    _.delay(()=>{
                        this.executeLayout();
                    },500)
                    
                }
                finally {
                    
                    this.model.editor.graph.getModel().endUpdate();

                    this.toCenter();

                    // 统计IDs
                    this.getAllCellIds();

                }
            },
            // 设置布局
            onSetLayout(cmd){
                this.model.graph.layout.default = cmd.name;
                if(cmd.value){
                    this.model.graph.layout.edgeStyle = cmd.value;
                }
                this.executeLayout();
            },
            // 清空当前画布
            onClear(){
                this.model.editor.execute("selectAll");
                this.model.editor.execute("delete");
            },
            executeLayout(){
                let graph = this.model.editor.graph;
                let parent = this.model.editor.graph.getDefaultParent();
                let layout = this.model.graph.layout;
                
                // 布局定义
                if(layout.default === 'hierarchical'){
                    // Layout hierarchical
                    graph.getModel().beginUpdate();
                    try {
                        layout.inst = new mxHierarchicalLayout(graph);
                        layout.inst.edgeStyle = layout.edgeStyle;
                        layout.inst.intraCellSpacing = 80;
                        layout.inst.interRankCellSpacing = 80;
                        layout.inst.execute(parent);
                    } catch (e) {
                        throw e;
                    } finally {
                        var morph = new mxMorphing(graph);  
                        morph.addListener(mxEvent.DONE, function(){  
                            graph.getModel().endUpdate();  
                        });  
                            
                        morph.startAnimation();  
                    }
                    
                } else if(layout.default === 'organic'){
                    // Layout Organic
                    graph.getModel().beginUpdate();
                    try {
                        layout.inst = new mxFastOrganicLayout(graph);
                        layout.inst.forceConstant = 140;
                        layout.inst.execute(parent);
                    } catch (e) {
                        throw e;
                    } finally {
                        graph.getModel().endUpdate();
                    }
                    
                } else if(layout.default === 'tree_vertical'){
                    /* Layout tree vertical */
                    graph.getModel().beginUpdate();
                    try {
                        layout.inst = new mxCompactTreeLayout(graph, false, false);
                        layout.inst.useBoundingBox = true;
                        layout.inst.edgeRouting = false;
                        layout.inst.levelDistance = 40;
                        layout.inst.nodeDistance = 60;
                        layout.edgeStyle = 4;
                        layout.inst.execute(parent);
                        layout.inst.isVertexMovable = function(cell){
                            console.log(1,cell)
                            return true;
                        };
                        var layoutMgr = new mxLayoutManager(graph);

                        layoutMgr.getLayout = function(cell){
                            if (cell.getChildCount() > 0){
                                return layout.inst;
                            }
                        };
                    } catch (e) {
                        throw e;
                    } finally {
                        graph.getModel().endUpdate();
                    }
                } else if(layout.default === 'tree_horizontal'){
                    /* Layout tree horizontal */
                    graph.getModel().beginUpdate();
                    try {
                        layout.inst = new mxCompactTreeLayout(graph, true, false);
                        layout.inst.useBoundingBox = true;
                        layout.inst.edgeRouting = false;
                        layout.inst.levelDistance = 40;
                        layout.inst.nodeDistance = 60;
                        layout.edgeStyle = 4;
                        layout.inst.execute(parent);
                        layout.inst.isVertexMovable = function(cell){
                            return true;
                        };
                        var layoutMgr = new mxLayoutManager(graph);

                        layoutMgr.getLayout = function(cell){
                            console.log(2,cell)
                            if (cell.getChildCount() > 0){
                                return layout.inst;
                            }
                        };
                        
                    } catch (e) {
                        throw e;
                    } finally {
                        graph.getModel().endUpdate();
                    }
                } else {
                    /* Layout Circle */
                    graph.getModel().beginUpdate();
                    try {
                        layout.inst = new mxCircleLayout(graph);
                        layout.inst.execute(parent);
                    } catch (e) {
                        throw e;
                    } finally {
                        graph.getModel().endUpdate();
                    }
                }
                
            },
            addChild(graph, cell){
                var model = this.model.editor.graph.getModel();
                var parent = this.model.editor.graph.getDefaultParent();
                var vertex;

                model.beginUpdate();
                try{
                    vertex = graph.insertVertex(parent, null, 'Double click to set name');
                    var geometry = model.getGeometry(vertex);

                    // Updates the geometry of the vertex with the
                    // preferred size computed in the graph
                    var size = graph.getPreferredSizeForCell(vertex);
                    geometry.width = size.width;
                    geometry.height = size.height;

                    // Adds the edge between the existing cell
                    // and the new vertex and executes the
                    // automatic layout on the parent
                    var edge = graph.insertEdge(parent, null, '', cell, vertex);

                    // Configures the edge label "in-place" to reside
                    // at the end of the edge (x = 1) and with an offset
                    // of 20 pixels in negative, vertical direction.
                    edge.geometry.x = 1;
                    edge.geometry.y = 0;
                    edge.geometry.offset = new mxPoint(0, -20);

                    addOverlays(graph, vertex, true);
                }
                finally
                {
                    model.endUpdate();
                }
                
                return vertex;
            },
            deleteSubtree(cell){
                // Gets the subtree from cell downwards
                var cells = [];
                this.model.editor.graph.traverse(cell, true, (vertex)=>{
                    cells.push(vertex);
                    
                    return true;
                });

                this.model.editor.graph.removeCells(cells);
            },
            createOverlayByTip(image, tooltip) {
                            
                let overlay = new mxCellOverlay(new mxImage(`/fs/assets/images/apps/png/severity/${image}.png?issys=true&type=open`,24,24), tooltip, mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_TOP, new mxPoint(-10,15));
                
                return overlay;
            },
            refreshEntityStatus(){
                const self = this;

                // 图所有节点
                let cells = _.map(self.model.editor.graph.getChildVertices(self.model.editor.graph.getDefaultParent()),function(v,k){
                                return {gid: v.id, name: v.value};
                            });
    
                let input = "('" + `${cells.join("','")}` + "')";

                let status = fsHandler.callFsJScript("/matrix/graph/graph_imap_data.js", encodeURIComponent(JSON.stringify(cells))).message;

                self.model.editor.graph.getModel().beginUpdate();

                try {
                    
                    _.forEach(status,function(v) {
                        let id = v.gid;
                        let status = v.status;
                        let cell = self.model.editor.graph.getModel().getCell(id);
                        let state = self.model.editor.graph.view.getState(cell);
                        
                        if (cell != null) {
                            
                            // Resets
                            self.model.editor.graph.removeCellOverlays(cell);
    
                            if (status >= 5) {

                                self.model.editor.graph.addCellOverlay(cell, self.createOverlayByTip(status, `${id}: 重大告警`));

                            } else if (status >3 && status < 5) {
                                self.model.editor.graph.addCellOverlay(cell, self.createOverlayByTip(status, `${id}: 严重告警`));
                            } else {
                                self.model.editor.graph.removeCellOverlays(cell);
                            } 
                        
                        }

                    })

                } catch(err){

                }
                finally {
                    self.model.editor.graph.getModel().endUpdate();
                }
            },
            onReload(){
                
                if(this.model.editor.graph){
                    
                    $(this.$refs.graphContainer.$el).empty();
                    $("#outlineContainer",this.$el).empty();

                    // 清空
                    this.model.editor.execute("selectAll");
                    this.model.editor.execute("delete");

                    // 重新初始化
                    this.init();
                    
                    this.outline();

                    this.setTheme(this.model.graph.theme.color);

                    // 更新toobar属性选择列表
                    this.model.graph.default.list = _.sortBy(_.map(_.keys(this.graphData.nodes[0]),function(v){
                        let k = v;
                        return {value: k, label: k};
                    }),['value'])
                }

                this.global.count = 0;

            },
            // 子图
            loadSubGraph(node){
                
                let term = "";
                if(node.direction=="out"){
                    term = `match ('${node.node.id}') - [*${node.step}] -> ()`;
                } else{
                    term = `match ('${node.node.id}') <- [*${node.step}] - ()`;
                }

                let rtn = fsHandler.callFsJScript("/matrix/graph/graph_service.js", encodeURIComponent(term)).message[0].graph;
                
                let allNodes = [];
                let allEdges = [];

                var graph = new mxGraph();
                var parent = graph.getDefaultParent();

                // Sets global styles
                var style = graph.getStylesheet().getDefaultEdgeStyle();
                style[mxConstants.STYLE_GRADIENTCOLOR] = _.sample(this.model.graph.path.color);

                this.model.editor.graph.getStylesheet().putCellStyle('column', style);
                
                graph.getModel().beginUpdate();
                
                try{

                    graph.getModel();
                    let nodes = {};
                    
                    // 添加节点类型，是否是新增、删除或者正常
                    allNodes =  _.map(rtn.nodes,(v)=>{
                                        return _.extend(v,{type:'normal'});
                                });
                    
                    //合并新增节点
                    try{
                        allNodes = _.extend(allNodes,_.map(rtn.diff.add.nodes,(v)=>{
                            return _.extend(v,{type:'add'});
                        }))
                    }catch(err){
                        
                    }
                    
                    //合并删除的节点
                    try{
                        allNodes =  _.concat(allNodes,_.map(rtn.diff.del.nodes,(v)=>{
                                        return _.extend(v,{type:'del'});
                                    }))
                    } catch(err){
                        
                    }

                    // 添加edge类型，包括正常的、新增的、删除的
                    allEdges = _.map(rtn.edges,(v)=>{
                        return _.extend(v,{type:"normal"});
                    });

                    //合并新增edge
                    try{
                        allEdges = _.map(allEdges,(v)=> {
                            if(_.find(rtn.diff.add.edges,{id:v.id})){
                                return _.extend(v,{type:'add'});
                            } else {
                                return v;
                            }
                        });
                    }catch(err){

                    }
                    
                    // 合并删除edge
                    try {
                        allEdges =  _.concat(allEdges,_.map(rtn.diff.del.edges,(v)=> {
                                        return _.extend(v,{type:'del'});
                                    }));
                    } catch(err){
                        
                    }

                    // 绘制节点
                    let fillColor = "";//`fillColor=${_.sample(this.model.graph.theme.predefineColors)}`;
                    let size = 50;
                    _.forEach(allNodes,(v)=>{

                        let _type = v._icon || 'matrix';
                        
                        // 可设置默认显示属性
                        let _name =  '';
                        
                        try{
                            if(window.URL_PARAMS_GRAPH){
                                _name = v[window.URL_PARAMS_GRAPH.title];
                            } else {
                                _name = v[this.model.graph.default.title];
                            }
                        } catch(err){
                            _name = v["id"];
                        }

                        // normal
                        // 选择节点渲染模式：icon/shape
                        let node = null;
                        let imageUrl = `${window.ASSETS_ICON}/entity/png/${_type}.png?type=download&issys=${window.SignedUser_IsAdmin}`;
                        
                        // icon渲染
                        if(this.model.control.ifIcon){
                            if(this.checkImgExists(`${_type}.png`)){
                                node = graph.insertVertex(parent, v.id, _name, 50, 50, 50, 50,`shape=image;html=1;image=${imageUrl};verticalLabelPosition=bottom;verticalAlign=top;`);
                            } else {
                                node = graph.insertVertex(parent, v.id, _name, 50, 50, size, size,`shape=ellipse;perimeter=ellipsePerimeter;html=1;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=middle;${fillColor}`);
                            }    
                        } 
                        // shape渲染
                        else {
                            node = graph.insertVertex(parent, v.id, _name, 50, 50, size, size,`shape=ellipse;perimeter=ellipsePerimeter;html=1;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=middle;${fillColor}`);
                        }

                        this.model.graph.allNodesIds.push(node.getId());

                        // node directory
                        _.extend(nodes,{[v.id]:node});


                        //add
                        if(v.type && v.type === 'add'){
                            let overlay = new mxCellOverlay(new mxImage(`/fs/assets/images/apps/png/flag/add.png?issys=true&type=download`,24,24), "新增", mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_TOP, new mxPoint(-10,15));
                            graph.addCellOverlay(node, overlay);
                        }

                        //delete
                        if(v.type && v.type === 'del'){
                            let overlay = new mxCellOverlay(new mxImage(`/fs/assets/images/apps/png/flag/delete.png?issys=true&type=download`,24,24), "删除", mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_TOP, new mxPoint(-10,15));
                            graph.addCellOverlay(node, overlay);
                        }

                    })

                    // 边界
                    let edges = {};
                    _.forEach(allEdges,(k,index)=>{
                        
                        let source = nodes[k.source];
                        let target = nodes[k.target];

                        let baseEdgeStyle = 'edgeStyle=elbowEdgeStyle;html=1;dashed=1;rounded=1;jettySize=auto;orthogonalLoop=1;endArrow=block;endFill=1;';
                        let direction = '';

                        if(k.twoway){
                            direction = 'startArrow=block;endArrow=block;endFill=1;';
                        }

                        if(k.type=='add'){
                            direction += 'strokeColor=#47fa28;strokeWidth=2;';
                        } else if(k.type=='del'){
                            direction += 'dashed=1;strokeColor=#ff0000;strokeWidth=2;';
                        } else {
                            direction += ''; 
                        }

                        // edge为path的样式
                        if(k.class === "path"){
                            baseEdgeStyle = 'edgeStyle=elbowEdgeStyle;orthogonalLoop=1;strokeWidth=1;dashed=1;startFill=0;endArrow=none;endFill=0;startArrow=none;orthogonal=1;elbow=vertical;';
                            let strokeColor = this.model.graph.path.colors[index] || _.sample(this.model.graph.path.colors);
                            let edge = graph.insertEdge(parent, k.id, k.class, source, target, baseEdgeStyle+direction+`strokeColor=${strokeColor}`);
                            return;
                        }

                        let edge = null;
                        try {
                            let edgeName = _.find(allEdges,{name:k.class}).remedy;
                            edge = graph.insertEdge(parent, k.id, edgeName, source, target, baseEdgeStyle+direction);
                        } catch(err){
                            edge = graph.insertEdge(parent, k.id, k.class, source, target, baseEdgeStyle+direction);
                        }
                        
                        // edge directory
                        try{
                            let id = source.getId() + ':' + target.getId();
                            _.extend(edges, { [id]: edge });
                        } catch(err){
                            console.log(err)
                        }
                        
                    })
                    
                }
                finally {
                    
                    graph.getModel().endUpdate();

                    // 合并图
                    this.model.editor.graph.getModel().mergeChildren(graph.getModel().getRoot().getChildAt(0), this.model.editor.graph.getDefaultParent());

                    // Executes the layout handler
                    _.delay(()=>{
                        this.executeLayout();
                    },500)

                    // Search journal
                    let cell = node.node.cell;
                    if (cell != null) {
                            
                        this.model.editor.graph.removeCellOverlays(cell);
                        let overlay = new mxCellOverlay(new mxImage(`/fs/assets/images/others/png/${this.global.count}.png?issys=true&type=open`,20,20), '', mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_TOP, new mxPoint(10,10));
                        this.model.editor.graph.addCellOverlay(cell, overlay);

                        // 定位cell
                        this.onPosition(cell.getId());
                    
                    }
                    // Search Step
                    this.global.count = this.global.count + 1;

                    // 加入高级搜索定义
                    this.$refs.searchToolbar.term = term;
                    //this.$refs.searchToolbar.search();

                    // 统计IDs
                    this.getAllCellIds();
                    
                }
            },
            // 图事件
            graphEvent(graph){

                try{
                    // 自定义ToolTip
                    graph.getTooltipForCell = function(cell){
                        if(!cell.edge){
                            return `<h5>ID：${cell.getId()}</h5>`;
                        } else {
                            return `ID：${cell.getId()}<br>
                                    起点：${cell.source.getId()}<br>
                                    终点：${cell.target.getId()}`;
                        }
                        
                    }

                    // Removes the source vertex 
                    graph.addListener(mxEvent.REMOVE_CELLS, (sender, evt)=> {
                        this.getAllCellIds();
                    });

                    // Add the source vertex
                    graph.addListener(mxEvent.ADD_CELLS, (sender, evt)=> {
                        this.getAllCellIds();
                    });

                    // 关系编辑
                    graph.addListener(mxEvent.CELL_CONNECTED, (sender, evt)=>{
                        
                        let edge = evt.getProperty('edge');
                        let sCell = edge.source;
                        let tCell = edge.target;

                        if(sCell && tCell){
                            _.extend(this.entity, {source: {id: sCell.getId(), value: sCell.getValue()}});

                            // 如果tCell为空，则为复制源实体
                            let id = tCell.getId();
                            let value = tCell.getValue();
                            let type = "";

                            if(_.indexOf(id,":") == -1){
                                tId = sCell.getId() + `_copy_${moment().format("SSS")}`;
                                tValue = sCell.getValue() + `_copy_${moment().format("SSS")}`;
                                tCell.setValue(tValue);
                                type = "new";
                            } else {
                                tId = tCell.getId();
                                tValue = tCell.getValue();
                            }
                            _.extend(this.entity, {target: {id: tId, value: tValue, type: type}});
                            this.entity.dialog.show = true;
                        }
                    })

                    // 监听双击事件
                    // graph.addListener(mxEvent.DOUBLE_CLICK, (sender, evt)=> {
                    //     let cell = evt.getProperty('cell');

                    //     if(!cell) return;

                    //     let id = cell.getId();
                    //     let value = cell.getValue();

                    //     // 点击获取关联信息
                    //     this.$root.$refs.graphDiagnosisRef.diagnosisAdd( {id:id, value:value, type:'event', cell: cell} );
                    // })

                    // 监听单击事件
                    graph.addListener(mxEvent.CLICK, (sender, evt)=> {
                        
                        let cell = evt.getProperty('cell');

                        if(!cell){
                            // 点击画板切换到图查询搜索栏
                            //this.$refs.searchToolbar.currentView = "topological-search-toolbar-graph";
                            return;
                        }
                        
                        let id = cell.getId();
                        let value = cell.getValue();
                        let node = {id: id, value: value, type:'event', cell: cell};

                        if(!cell.edge){
                            if(this.$refs.searchToolbar.currentView==='topological-search-toolbar-graphAdv'){
                                //this.$refs.searchToolbar.currentView = "topological-search-toolbar-graph";
                            }
                            _.delay(()=>{
                                eventHub.$emit("TOPOLOGICAL-ANALYISS-TRACE", node);
                            },500)   
                        }

                    });

                    // 鼠标停留到元素上边缘高亮显示
                    let track = new mxCellTracker(graph);
                    track.mouseMove = _.debounce((sender, me)=> {
                        
                        try{
                            // 刷新状态
                            this.refreshEntityStatus();
                        } catch(err){

                        }
                        
                    },2000);

                    // 滚轮缩放
                    mxEvent.addMouseWheelListener((evt, up)=> {
                        // if (up) {
                        //     graph.zoomIn();
                        // } else {
                        //     graph.zoomOut();
                        // }
                        // mxEvent.consume(evt);
                    });

                    // 监听拖拽事件
                    mxEvent.addListener(container, 'dragover', function(evt){
                        if (graph.isEnabled()){
                            evt.stopPropagation();
                            evt.preventDefault();
                        }
                    });
                    // 监听拖入事件
                    const self = this;
                    mxEvent.addListener(container, 'drop', function(evt){
                        if (graph.isEnabled()){
                            evt.stopPropagation();
                            evt.preventDefault();

                            // Gets drop location point for vertex
                            var pt = mxUtils.convertPoint(graph.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
                            var tr = graph.view.translate;
                            var scale = graph.view.scale;
                            var x = pt.x / scale - tr.x;
                            var y = pt.y / scale - tr.y;
                            
                            // Converts local entity to graph cell
                            let addCellToGraph = function(){
                                
                                graph.getModel().beginUpdate();

                                try{

                                    graph.getModel();
                                    let parent = graph.getDefaultParent();

                                    _.forEach(items,(v)=>{

                                        let cell = graph.getModel().getCell(v.id);

                                        if(cell){
                                            self.$message({
                                                type: "info",
                                                message: "已有该实体"
                                            })
                                            return;
                                        }

                                        let type = _.head(v.id.split(":")) || 'matrix';

                                        // 可设置默认显示属性
                                        let name =  '';
                                        
                                        try{
                                            if(window.URL_PARAMS_GRAPH){
                                                name = v[window.URL_PARAMS_GRAPH.title];
                                            } else {
                                                name = v[self.model.graph.default.title];
                                            }
                                        } catch(err){
                                            name = v["id"];
                                        }

                                        // normal
                                        // 选择节点渲染模式：icon/shape
                                        let node = null;
                                        let imageUrl = `${window.ASSETS_ICON}/entity/png/${type}.png?type=download&issys=${window.SignedUser_IsAdmin}`;
                                        
                                        // icon渲染
                                        if(self.model.control.ifIcon){
                                            if(self.checkImgExists(`${type}.png`)){
                                                node = graph.insertVertex(parent, v.id, name, x, y, 60, 60,`shape=image;html=1;image=${imageUrl};verticalLabelPosition=bottom;verticalAlign=top;`);
                                            } else {
                                                node = graph.insertVertex(parent, v.id, name, x, y, 50, 50,`shape=ellipse;perimeter=ellipsePerimeter;html=1;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=middle;`);
                                            }    
                                        } 
                                        // shape渲染
                                        else {
                                            node = graph.insertVertex(parent, v.id, name, x, y, 50, 50,`shape=ellipse;perimeter=ellipsePerimeter;html=1;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=middle;`);
                                        }

                                        node.vertex = true;

                                        // node directory
                                        _.extend(self.model.graph.nodes,{[v.id]:node});

                                        // 定位到cell
                                        _.delay(()=>{
                                            graph.scrollCellToVisible(cell);
                                            graph.setSelectionCell(cell);
                                        },3500)

                                    })
                                
                                    
                                } catch(err){

                                } finally {
                                    graph.getModel().endUpdate();
                                }
                            };

                            var items = [JSON.parse(event.dataTransfer.getData("Text"))];

                            addCellToGraph(items);
                        }
                    });

                } catch(err){}
            },
            // 获取所有cell ids
            getAllCellIds(){
                try{
                    let parent = this.model.editor.graph.getDefaultParent();
                    let cells = this.model.editor.graph.getChildVertices(parent);
                    
                    // IDs
                    this.model.graph.allNodesIds = _.uniq(_.map(cells,(v,k)=>{
                                        return v.getId();
                                    })).sort();
                    
                } catch(err){
                    this.model.graph.allNodesIds = [];
                }
            },
            onPosition(id){
                
                let graph = this.model.editor.graph;
                let cell = graph.getModel().getCell(id);

                try{
                    // 恢复图实际大小
                    this.model.editor.execute("actualSize");    
                    
                    let containerW = $(this.$refs.graphContainer.$el).width();
                    let containerH = $(this.$refs.graphContainer.$el).height();
                    let x =-cell.geometry.x + ( containerW - cell.geometry.width) / 2;
                    let y =-cell.geometry.y + ( containerH - cell.geometry.height) / 2;
                    graph.getView().setTranslate(x,y);

                    graph.scrollCellToVisible(cell);
                    graph.setSelectionCells([cell]);

                    // 选择节点突出显示
                    let cStyle = [[mxConstants.STYLE_PERIMETER_SPACING,8]];
                    this.setCellStyle(cell, cStyle);
                } catch(err){
                    
                    // 当前画布中不包含该实体
                    this.$message({
                        type: "info",
                        message: "画布没有该实体 "
                    })
                }
                
            },
            onTimeLine(){
                this.model.graph.footbar.show = !this.model.graph.footbar.show;
                if(this.model.graph.footbar.show){
                    // this.layout.splitInst = Split([this.$refs.graphContainer.$el, this.$refs.footer.$el], {
                    //     sizes: [60,40],
                    //     minSize: [0, 0],
                    //     gutterSize: 5,
                    //     cursor: 'col-resize',
                    //     direction: 'vertical'
                    // });
                } else {
                    // this.layout.splitInst.destroy();
                }
            },
            forward(item){
                if(this.model.graph.history.length > 1){
                    this.model.graph.history = _.slice(this.model.graph.history,0,_.findIndex(this.model.graph.history,{id:item.id})+1);
                }
                this.$root.$refs.graphViewRef.search( encodeURIComponent(item.term));
            },
            outline(){
                this.model.graph.outline = new mxOutline(this.model.editor.graph, $("#outlineContainer",this.$el)[0]);
            },
		    saveas(){
				const self = this;

                let encoder = new mxCodec();
                let node = encoder.encode(self.model.editor.graph.getModel());
                let xml = mxUtils.getPrettyXml(node);

                alertify.prompt("另存为", function (e, str) {
                    // str is the input text
                    if (e) {
                        // user clicked "ok"
	                    let parent = '/opt/creative/admin';
	                    let ftype = 'imap';
	                    let name = `${str}.${ftype}`;
	                    let attr = {remark: null, ctime: _.now(), author: window.SignedUser_UserName, type: 'imap', icon: `${window.ASSETS_ICON}/files/png/imap.png?type=download&issys=${window.SignedUser_IsAdmin}`};
                        let rtn = fsHandler.fsNew('file', parent, name, xml, attr);
	                    if(rtn == 1){

	                        let item = _.merge({parent:parent,name:name,attr:attr,ftype:ftype},{lang: 'zh', action:'run'});

                            let url = fsHandler.genFsUrl(item,null,null);

                            alertify.success(`已保存到/fs${[parent,name].join("/")}，<a class="btn btn-success" href="${url}" target="_blank">点击前往编辑或查看</a>`);
	                    }
                    } else {
                        // user clicked "cancel"
                    }
                }, "");

                $(".alertify-prompt .alertify-message").css('height','5vh');

		    },
            nodeTitle() {

                // 文件图模式
                if(window.URL_PARAMS_ITEM){
                    this.model.graph.default.list = [{value: "id", label: "ID"},{value: "value", label: "Value"}];    
                } else {
                    this.model.graph.default.list = _.sortBy(_.map(_.keys(this.graphData.nodes[0]),function(v){
                        let k = v;
                        return {value: k, label: k};
                    }),['value'])
                }

            },
            toCenter(){
                this.model.editor.execute("fit");
                _.delay(()=>{
                    this.model.editor.graph.center(true,false,0.5,0.5);//将画布放到容器中间
                },500)
                /* var cx = '50vw';//this.model.editor.graph.container.clientWidth / 2;
                var cy = '50vh';//this.model.editor.graph.container.clientHeight / 2;

                $("#graphContainer > svg").css({
                    'transform': `translate(${cx},${cy})`
                })*/

                // this.model.editor.graph.fit();//自适应
                // this.model.editor.graph.center(true,false,0.1,0.5);//将画布放到容器中间
                // var sc = this.model.editor.graph.getView().getScale();//获取当前的缩放比例
                // this.model.editor.graph.zoomTo(Math.round(sc/2));//在缩放一半，否则是满屏状态，不好看
            },
            // 绘制路径
            addPath(paths){
                
                let pathsByOmitProp = _.map(paths,(v)=>{
                                return _.omit(v,['num','class']);
                            });
                
                this.model.editor.graph.getModel().beginUpdate();
                
                try{
                    this.model.editor.graph.getModel()

                    this.removePath();
                    
                    _.forEach(pathsByOmitProp,(v,index)=>{
                        // keys
                        var keys = _.keys(v);
                        // values
                        var values = _.values(v);
                        
                        for(var i=0;i<keys.length;i++){
                            let source = this.model.graph.nodes[v[keys[i]]];
                            let target = this.model.graph.nodes[v[keys[i+1]]];
                            if(_.isUndefined(target)){
                                return;
                            }
                            let baseEdgeStyle = 'edgeStyle=elbowEdgeStyle;orthogonalLoop=1;strokeWidth=2;dashed=1;startFill=0;endArrow=none;endFill=0;startArrow=none;orthogonal=1;elbow=vertical;';
                            let strokeColor = this.model.graph.path.colors[index] || _.sample(this.model.graph.path.colors);
                            
                            let hasPath = this.model.editor.graph.getModel().getCell(`path${index+1}${i}`);
                            if(!hasPath){
                                let path = this.model.editor.graph.insertEdge(this.model.graph.parent, `path${index+1}${i}`, `${index+1}`, source, target, baseEdgeStyle+`strokeColor=${strokeColor};`);
                                this.model.graph.path.list.push(path);
                            }
                        }
                    })

                    
                    this.entity.dialog.show = false;

                    // Executes the layout handler
                    _.delay(()=>{
                        this.executeLayout();
                    },500)

                } catch(err){

                }
                finally{
                    this.model.editor.graph.getModel().endUpdate();
                }
            },
            // 删除路径
            removePath(){
                
                if(this.model.graph.path.list.length == 0){
                    return false;
                }

                // Cancels interactive operations
                this.model.editor.graph.escape();

                let cells = this.model.graph.path.list;
                
                if (cells != null && cells.length > 0){
                    this.model.editor.graph.removeCells(cells, true);
                }
            },
            onPrint(){
                let scale = mxUtils.getScaleForPageCount(1, this.model.editor.graph);
                let preview = new mxPrintPreview(this.model.editor.graph, scale);
                preview.open();
            },
            setTheme(bgColor){

                $("body").css({
                    "background": bgColor
                });

                $(this.$refs.graphContainer.$el).css({
                    "backgroundColor":"transparent"
                });

                let cStyle = [mxConstants.STYLE_FONTCOLOR,this.setThemeFont(bgColor)];
                this.setCellsStyle(cStyle);

                localStorage.setItem(`GRAPH-VIEW-THEME-${window.SignedUser_UserName}`,bgColor);
            },
            setCellsStyle(cStyle){
                
                this.model.editor.graph.escape();

                let cells = this.model.editor.graph.getChildVertices(this.model.editor.graph.getDefaultParent());
                
                if (cells != null && cells.length > 0){
                    _.forEach(cells,(v)=>{
                        let style = this.model.editor.graph.getModel().getStyle(v);
                        let newStyle = mxUtils.setStyle(style, cStyle[0], cStyle[1]);
                        let cs = [];
                        cs[0] = v;
                        this.model.editor.graph.setCellStyle(newStyle,cs);
                    })
                }
            },
            setCellStyle(cell,cStyle){
                
                this.model.editor.graph.escape();

                let style=this.model.editor.graph.getModel().getStyle(cell);
                _.forEach(cStyle,(v)=>{
                    let newStyle=mxUtils.setStyle(style, v[0], v[1]);
                    let cs= new Array();
                    cs[0]=cell;
                    this.model.editor.graph.setCellStyle(newStyle,cs);
                })

            },
            setThemeFont(hexcolor){
                try{

                
                    // If a leading # is provided, remove it
                    if (hexcolor.slice(0, 1) === '#') {
                        hexcolor = hexcolor.slice(1);
                    }

                    // If a three-character hexcode, make six-character
                    if (hexcolor.length === 3) {
                        hexcolor = hexcolor.split('').map(function (hex) {
                            return hex + hex;
                        }).join('');
                    }

                    // Convert to RGB value
                    var r = parseInt(hexcolor.substr(0,2),16);
                    var g = parseInt(hexcolor.substr(2,2),16);
                    var b = parseInt(hexcolor.substr(4,2),16);

                    // Get YIQ ratio
                    var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;

                    // Check contrast
                    return (yiq >= 128) ? 'black' : 'white';

                } catch(err){
                    return 'black';
                }

            },
            onZoomIn(){
                this.model.editor.graph.zoomIn();
            },
            onZoomOut(){
                this.model.editor.graph.zoomOut();
            },
            onFit(){
                this.model.editor.execute("fit");
            },
            editIt(){
                let item = { 
                                parent:window.URL_PARAMS_ITEM.parent, 
                                name:window.URL_PARAMS_ITEM.name, 
                                ftype:window.URL_PARAMS_ITEM.ftype, 
                                lang: window.MATRIX_LANG, 
                                attr:window.URL_PARAMS_ITEM.attr, 
                                action:'edit'
                            };

                let url = fsHandler.genFsUrl(item,null,null);

                window.open(url, "_parent");
            },
            addCell(tNode){
                
                try{
                    // normal
                    let type = tNode.key.split(":")[0];
                    let node = this.model.editor.graph.insertVertex(this.model.graph.parent, tNode.key, tNode.label, 50, 50, 120, 50,
                                `shape=image;html=1;image=${window.ASSETS_ICON}/entity/png/${type}.png?type=download&issys=${window.SignedUser_IsAdmin};verticalLabelPosition=bottom;verticalAlign=top;`);
                    
                    // node directory
                    _.extend(this.model.graph.nodes,{[tNode.key]:node});

                } catch(err){
                    
                }
            },
            addEdge(sNode,tNode){
                
                this.model.editor.graph.getModel().beginUpdate();

                let source = this.model.graph.nodes[sNode];
                
                try{

                    this.model.editor.graph.getModel();

                    _.forEach(tNode, (v)=>{
                        
                        let target = null;

                        // 如果没有Cell，先新建Cell
                        if(!this.model.graph.nodes[v.key]){
                            target = this.addCell(v)
                        }

                        target = this.model.graph.nodes[v.key];
                        
                        let id = sNode + '-' + target.getId();
                        let edgeNode = {id:id, class:''};

                        let baseEdgeStyle = 'edgeStyle=elbowEdgeStyle;html=1;rounded=1;jettySize=auto;orthogonalLoop=1;endArrow=block;endFill=1;';
                        let direction = 'startArrow=block;endArrow=block;endFill=1;';

                        // add
                        direction += 'strokeColor=#47fa28;strokeWidth=2;';

                        let edge = null;
                        try {
                            edge = this.model.editor.graph.insertEdge(this.model.graph.parent, edgeNode.id, '', source, target, baseEdgeStyle+direction);
                        } catch(err){
                            edge = this.model.editor.graph.insertEdge(this.model.graph.parent, edgeNode.id, edgeNode.class, source, target, baseEdgeStyle+direction);
                        }

                        // edges directory
                        _.extend(this.model.graph.edges, {[id]:edge});
                    })
                    
                    // Executes the layout handler
                    _.delay(()=>{
                        this.executeLayout();
                    },500)
                    
                } finally {
                    this.model.editor.graph.getModel().endUpdate();
                }
            },
            removeEdge(sNode,tNode){
                
                this.model.editor.graph.getModel().beginUpdate();
                
                try{

                    let cells = _.map(tNode, (v)=>{
                                    let id = sNode + '-' + v.key;
                                    return this.model.editor.graph.getModel().getCell(id);
                                });

                    this.model.editor.graph.getModel();

                    this.model.editor.graph.escape();
                    
                    if (cells != null && cells.length > 0){
                        this.model.editor.graph.removeCells(cells, true);
                    }
                    
                    // Executes the layout handler
                    _.delay(()=>{
                        this.executeLayout();
                    },500)
                    
                } finally {
                    this.model.editor.graph.getModel().endUpdate();
                }
            },
            onFullScreen(){
                if (screenfull.isEnabled) {
                    if(this.model.control.ifFullScreen){
                        screenfull.exit(this.$el);
                        this.model.control.ifFullScreen = false;   
                    
                        $("#header").show();
                        $("#aside").show();
                        $("#footer").show();
                        $("#content").css("margin-left","60px");
                        $(this.$root.$refs.main.$el).css("height","calc(100vh - 85px)");
                    } else {
                        screenfull.request();
                        this.model.control.ifFullScreen = true;

                        $("#header").hide();
                        $("#aside").hide();
                        $("#footer").hide();
                        $("#content").css("margin-left","0px");
                        $(this.$root.$refs.main.$el).css("height","calc(100vh - 50px)");
                    }   
                }
                //this.model.control.ifFullScreen = mx.fullScreenByEl(this.$el);
            },
            onToggleIcon(){
                this.model.control.ifIcon = !this.model.control.ifIcon;
                localStorage.setItem("TOPOLOGICAL-RENDER-TYPE",this.model.control.ifIcon);
                this.onReload();
            },
            saveEntityAndEdge(){

            },
            onEntityDialogClosed(){
                this.entity.soure = {};
                this.entity.target = {};
                if(this.entity.dialog.ifClose == true){
                    this.model.editor.execute('undo');
                }
            },
            onSaveEdgeType(){
                
                let term = encodeURIComponent( JSON.stringify(_.extend(this.entity.newEdgeType.model, {action: "create"})) );
                let rtn = fsHandler.callFsJScript("/matrix/edge/edgeAction.js",term);
                
                if(rtn.status == 'ok'){
                    this.$message({
                        type: "success",
                        message: "新建关系类型成功！"
                    })
                    this.entity.newEdgeType.show = false;
                }
                
            },  
            removeEntity(cell){
                
                if(!cell){
                    this.$message({
                        type: "info",
                        message: "请确认所选实体！"
                    })
                    return false;
                }

                // 删除节点
                if(!cell.edge){
                    this.$confirm(`确定删除该实体？`, '提示', {
                            confirmButtonText: '确定',
                            cancelButtonText: '取消',
                            type: 'warning'
                        }).then(() => {
                            // entity action
                            let entity = {id:cell.getId(),type:'delete'};
                            fsHandler.callFsJScript("/matrix/graph/entity-action.js",encodeURIComponent(JSON.stringify(entity)));

                            // graph action
                            cell.removeFromParent();
                            this.model.editor.graph.refresh(cell);
                            
                            this.$message({
                                message: '删除实体成功',
                                type: 'success'
                            }); 
                        }).catch(() => {
                            
                        });
                }
                // 删除关系
                else{
                    this.$confirm(`确定删除该实体关系？`, '提示', {
                            confirmButtonText: '确定',
                            cancelButtonText: '取消',
                            type: 'warning'
                        }).then(() => {
                            
                            // entity action
                            let sourceId = cell.getId().split("-")[0];
                            let targetId = cell.getId().split("-")[1];
                            let type = cell.getValue();
                            let edges = {
                                id: sourceId, 
                                type: type, 
                                action:"-", 
                                value: _.map([targetId],(v)=>{
                                    return {key: v, label: v};
                                })
                            };
                    
                            // 更新关系
                            let rtn = fsHandler.callFsJScript("/matrix/graph/edges-action.js",encodeURIComponent(JSON.stringify(edges)));
                            
                            if(rtn.status == 'ok'){
                                this.$message({
                                    type: "success",
                                    message: "删除关系成功！"
                                })
                                // graph action
                                cell.removeFromParent();
                                this.model.editor.graph.refresh(cell);

                            } else {
                                this.$message({
                                    type: "error",
                                    message: "删除关系失败！"
                                })
                            }

                        }).catch(() => {
                            
                        });
                }
            },
            addEntity(entity){
                let rtn = null;

                if(!this.entity.edges.value){
                    this.$message({
                        type: "info",
                        message: "请选择关系类型！"
                    });
                    return false;
                }

                if(!entity){
                    
                    rtn = fsHandler.callFsJScript("/matrix/graph/entity-action.js",encodeURIComponent(JSON.stringify(this.entity.target))).message;
                }

                this.$message({
                    type: "success",
                    message: "实体插入成功！"
                })

                this.updateEntityEdge();
            },
            updateEntityEdge(){
                
                if(!this.entity.edges.value){
                    this.$message({
                        type: "info",
                        message: "请选择关系类型！"
                    });
                    return false;
                }

                if(!this.entity.source.id){
                    this.$message({
                        type: "info",
                        message: "请确定起始节点！"
                    });
                    return false;
                }

                if(!this.entity.target.id){
                    this.$message({
                        type: "info",
                        message: "请确定目标节点！"
                    });
                    return false;
                }


                /* value = [
                    {
                    "key": "linux:wecise",
                    "label": "linux:wecise",
                    "class": "/matrix/entity/linux",
                    "disabled": 0
                    }
                ] */
                
                let edges = {
                                id:this.entity.source.id, 
                                type:this.entity.edges.value, 
                                action:"+", 
                                value: _.map([this.entity.target],(v)=>{
                                    return {key: v.id, label: v.value};
                                })
                            };
                    
                // 更新关系
                let rtn = fsHandler.callFsJScript("/matrix/graph/edges-action.js",encodeURIComponent(JSON.stringify(edges)));
                            
                if(rtn.status == 'ok'){
                    this.$message({
                        type: "success",
                        message: "创建关系成功！"
                    })
                    
                    this.entity.dialog.ifClose = false;
                    this.entity.dialog.show = false;

                } else {
                    this.$message({
                        type: "error",
                        message: "创建关系失败！"
                    })
                }

            },
            onTagClick(event,type,value){
                event.preventDefault();
                event.stopPropagation();
                
                const self = this;
                window.flowEdges = [];
                
                this.model.control.ifIcon = false;
                let vertices = this.model.editor.graph.getChildVertices(this.model.editor.graph.getDefaultParent());
                let edges = this.model.editor.graph.getChildEdges(this.model.editor.graph.getDefaultParent());
                

                let reset = function(){
                    _.forEach(vertices,(v)=>{
                        self.model.editor.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, "blue", [v]);
                        self.model.editor.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, "#333333", [v]);
                        self.model.editor.graph.setCellStyles(mxConstants.STYLE_GRADIENTCOLOR, "blue", [v]);
                    })
                    
                    _.forEach(edges,(v)=>{
                        self.model.editor.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, "#000000", [v]);
                        self.model.editor.graph.setCellStyles(mxConstants.STYLE_STROKEWIDTH, "1", [v]);
                    })
                    
                    _.forEach(window.flowEdges,(v)=>{
                        resetFlowEffect(v);
                    });

                    clearInterval(window.flowEffectInterval);
                }

                let setVertex = function(){
                    _.forEach(vertices,(v)=>{
                        if(!_.startsWith(v.getId(),value)){
                            self.model.editor.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, "#f6f6f6", [v]);
                            self.model.editor.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, "#333333", [v]);
                            self.model.editor.graph.setCellStyles(mxConstants.STYLE_GRADIENTCOLOR, "#ffffff", [v]);
                        } 
                    })
                }

                let setEdge = function(){
                    
                    _.forEach(edges,(v)=>{
                        if(v.getValue() != value){
                            self.model.editor.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, "#f6f6f6", [v]);
                            self.model.editor.graph.setCellStyles(mxConstants.STYLE_STROKEWIDTH, "3", [v]);
                        } else {
                            window.flowEdges.push(v);
                        }
                    })

                    window.flowEffectInterval = setInterval(()=>{
                        _.forEach(window.flowEdges,(v)=>{
                            setFlowEffect(v);
                        });
                    },50)
                }


                let setFlowEffect = function(edge){
                    // Adds animation to edge shape and makes "pipe" visible
                    var state = self.model.editor.graph.view.getState(edge);
                    state.shape.node.getElementsByTagName('path')[0].removeAttribute('visibility');
                    state.shape.node.getElementsByTagName('path')[0].setAttribute('stroke-width', '6');
                    state.shape.node.getElementsByTagName('path')[0].setAttribute('stroke', 'lightGray');
                    state.shape.node.getElementsByTagName('path')[1].setAttribute('class', 'flow');
                }

                let resetFlowEffect = function(edge){
                    try{
                        var state = self.model.editor.graph.view.getState(edge);
                        console.log(edge,state.shape.node.getElementsByTagName('path')[1])
                        // state.shape.node.getElementsByTagName('path')[0].setAttribute('visibility','visible');
                        // state.shape.node.getElementsByTagName('path')[0].setAttribute('stroke-width', '1');
                        // state.shape.node.getElementsByTagName('path')[0].setAttribute('stroke', '#333333');
                        state.shape.node.getElementsByTagName('path')[1].removeAttribute('class');
                    } catch(err){
                        console.log(err)
                    }
                }

                // 重置样式
                reset();
                // 设置样式
                if(type == 'vertex'){
                    setVertex();
                } else {
                    setEdge();
                }
                
            }
	    }
	
	}
	</script>

</code>
